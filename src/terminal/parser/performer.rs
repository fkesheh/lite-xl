//! Implementation of the vte::Perform trait for handling ANSI escape sequences.
//!
//! This module provides the `AnsiPerformer` which processes all terminal escape
//! sequences and converts them into high-level terminal actions.

use super::sequences::{
    AttributeChange, Color, Mode, NamedColor, Rgb, TerminalAction,
    UnderlineStyle,
};
use vte::{Params, Perform};

/// Handler for ANSI escape sequences.
///
/// Implements the `vte::Perform` trait to parse and handle all ANSI/VT escape sequences,
/// converting them into high-level `TerminalAction` events.
#[derive(Debug)]
pub struct AnsiPerformer {
    /// Queue of actions generated by parsing
    actions: Vec<TerminalAction>,
    /// Current OSC (Operating System Command) being built
    osc_buffer: Vec<Vec<u8>>,
    /// Current DCS (Device Control String) being built
    dcs_buffer: Vec<u8>,
}

impl Default for AnsiPerformer {
    fn default() -> Self {
        Self::new()
    }
}

impl AnsiPerformer {
    /// Create a new ANSI performer
    pub fn new() -> Self {
        Self {
            actions: Vec::new(),
            osc_buffer: Vec::new(),
            dcs_buffer: Vec::new(),
        }
    }

    /// Take all pending actions, clearing the internal queue
    pub fn take_actions(&mut self) -> Vec<TerminalAction> {
        std::mem::take(&mut self.actions)
    }

    /// Get reference to pending actions without clearing
    pub fn actions(&self) -> &[TerminalAction] {
        &self.actions
    }

    /// Add an action to the queue
    fn push_action(&mut self, action: TerminalAction) {
        self.actions.push(action);
    }

    /// Handle SGR (Select Graphic Rendition) sequences
    fn handle_sgr(&mut self, params: &Params) {
        if params.is_empty() {
            self.push_action(TerminalAction::ResetAttributes);
            return;
        }

        let mut iter = params.iter();
        while let Some(param) = iter.next() {
            match param[0] {
                // Reset
                0 => self.push_action(TerminalAction::ResetAttributes),

                // Bold
                1 => self.push_action(TerminalAction::SetAttribute(AttributeChange::Bold)),

                // Dim/faint
                2 => self.push_action(TerminalAction::SetAttribute(AttributeChange::Dim)),

                // Italic
                3 => self.push_action(TerminalAction::SetAttribute(AttributeChange::Italic)),

                // Underline
                4 => self.push_action(TerminalAction::SetAttribute(AttributeChange::Underline(
                    UnderlineStyle::Single,
                ))),

                // Slow blink
                5 => self.push_action(TerminalAction::SetAttribute(AttributeChange::Blink)),

                // Rapid blink
                6 => self.push_action(TerminalAction::SetAttribute(AttributeChange::BlinkFast)),

                // Reverse video
                7 => self.push_action(TerminalAction::SetAttribute(AttributeChange::Reverse)),

                // Conceal/hidden
                8 => self.push_action(TerminalAction::SetAttribute(AttributeChange::Hidden)),

                // Strikethrough
                9 => self.push_action(TerminalAction::SetAttribute(
                    AttributeChange::Strikethrough,
                )),

                // Double underline
                21 => self.push_action(TerminalAction::SetAttribute(AttributeChange::Underline(
                    UnderlineStyle::Double,
                ))),

                // Normal intensity (not bold or dim)
                22 => self.push_action(TerminalAction::SetAttribute(
                    AttributeChange::NormalIntensity,
                )),

                // Not italic
                23 => self.push_action(TerminalAction::SetAttribute(AttributeChange::NoItalic)),

                // Not underlined
                24 => self.push_action(TerminalAction::SetAttribute(AttributeChange::NoUnderline)),

                // Not blinking
                25 => self.push_action(TerminalAction::SetAttribute(AttributeChange::NoBlink)),

                // Not reversed
                27 => self.push_action(TerminalAction::SetAttribute(AttributeChange::NoReverse)),

                // Not hidden
                28 => self.push_action(TerminalAction::SetAttribute(AttributeChange::NoHidden)),

                // Not strikethrough
                29 => self.push_action(TerminalAction::SetAttribute(
                    AttributeChange::NoStrikethrough,
                )),

                // Foreground colors (30-37)
                30..=37 => {
                    let color = NamedColor::from_ansi((param[0] - 30) as u8).unwrap();
                    self.push_action(TerminalAction::SetForeground(Color::Named(color)));
                }

                // Extended foreground color (38)
                38 => {
                    if let Some(color) = Self::parse_color(&mut iter) {
                        self.push_action(TerminalAction::SetForeground(color));
                    }
                }

                // Default foreground
                39 => self.push_action(TerminalAction::ResetForeground),

                // Background colors (40-47)
                40..=47 => {
                    let color = NamedColor::from_ansi((param[0] - 40) as u8).unwrap();
                    self.push_action(TerminalAction::SetBackground(Color::Named(color)));
                }

                // Extended background color (48)
                48 => {
                    if let Some(color) = Self::parse_color(&mut iter) {
                        self.push_action(TerminalAction::SetBackground(color));
                    }
                }

                // Default background
                49 => self.push_action(TerminalAction::ResetBackground),

                // Bright foreground colors (90-97)
                90..=97 => {
                    let color = NamedColor::from_ansi((param[0] - 90 + 8) as u8).unwrap();
                    self.push_action(TerminalAction::SetForeground(Color::Named(color)));
                }

                // Bright background colors (100-107)
                100..=107 => {
                    let color = NamedColor::from_ansi((param[0] - 100 + 8) as u8).unwrap();
                    self.push_action(TerminalAction::SetBackground(Color::Named(color)));
                }

                // Unknown SGR parameter - ignore
                _ => {}
            }
        }
    }

    /// Parse extended color sequences (256-color and RGB)
    fn parse_color<'a>(iter: &mut impl Iterator<Item = &'a [u16]>) -> Option<Color> {
        match iter.next() {
            // 256-color mode
            Some(&[5]) => {
                iter.next()
                    .and_then(|p| p.first())
                    .map(|&idx| Color::Indexed(idx as u8))
            }
            // RGB mode
            Some(&[2]) => {
                let r = iter.next()?.first()? & 0xFF;
                let g = iter.next()?.first()? & 0xFF;
                let b = iter.next()?.first()? & 0xFF;
                Some(Color::Rgb(Rgb::new(r as u8, g as u8, b as u8)))
            }
            _ => None,
        }
    }

    /// Handle CSI (Control Sequence Introducer) sequences
    fn handle_csi(&mut self, params: &Params, intermediates: &[u8], ignore: bool, action: char) {
        if ignore {
            return;
        }

        // Handle private mode sequences (prefixed with ?)
        if intermediates.first() == Some(&b'?') {
            self.handle_private_mode(params, action);
            return;
        }

        // Get the first parameter or default to 1
        let arg = params
            .iter()
            .next()
            .and_then(|p| p.first())
            .map(|&n| n as usize)
            .filter(|&n| n != 0)
            .unwrap_or(1);

        match action {
            // Cursor movement
            'A' => self.push_action(TerminalAction::CursorUp(arg)),
            'B' => self.push_action(TerminalAction::CursorDown(arg)),
            'C' => self.push_action(TerminalAction::CursorForward(arg)),
            'D' => self.push_action(TerminalAction::CursorBackward(arg)),
            'E' => {
                self.push_action(TerminalAction::CursorDown(arg));
                self.push_action(TerminalAction::CursorGoToColumn(1));
            }
            'F' => {
                self.push_action(TerminalAction::CursorUp(arg));
                self.push_action(TerminalAction::CursorGoToColumn(1));
            }
            'G' => self.push_action(TerminalAction::CursorGoToColumn(arg)),
            'd' => self.push_action(TerminalAction::CursorGoToLine(arg)),

            // Cursor positioning (H and f are equivalent)
            'H' | 'f' => {
                let line = params
                    .iter()
                    .nth(0)
                    .and_then(|p| p.first())
                    .map(|&n| n as usize)
                    .filter(|&n| n != 0)
                    .unwrap_or(1);
                let col = params
                    .iter()
                    .nth(1)
                    .and_then(|p| p.first())
                    .map(|&n| n as usize)
                    .filter(|&n| n != 0)
                    .unwrap_or(1);
                self.push_action(TerminalAction::CursorGoTo { line, col });
            }

            // Save/restore cursor
            's' => self.push_action(TerminalAction::CursorSave),
            'u' => self.push_action(TerminalAction::CursorRestore),

            // Erase in display
            'J' => match arg {
                0 => self.push_action(TerminalAction::ClearToEndOfScreen),
                1 => self.push_action(TerminalAction::ClearToBeginningOfScreen),
                2 | 3 => self.push_action(TerminalAction::ClearScreen),
                _ => {}
            },

            // Erase in line
            'K' => match arg {
                0 => self.push_action(TerminalAction::ClearToEndOfLine),
                1 => self.push_action(TerminalAction::ClearToBeginningOfLine),
                2 => self.push_action(TerminalAction::ClearLine),
                _ => {}
            },

            // Scrolling region
            'r' => {
                let top = params
                    .iter()
                    .nth(0)
                    .and_then(|p| p.first())
                    .map(|&n| n as usize)
                    .filter(|&n| n != 0)
                    .unwrap_or(1);
                let bottom = params
                    .iter()
                    .nth(1)
                    .and_then(|p| p.first())
                    .map(|&n| n as usize)
                    .filter(|&n| n != 0)
                    .unwrap_or(usize::MAX);

                if top < bottom {
                    self.push_action(TerminalAction::SetScrollRegion { top, bottom });
                }
            }

            // Insert/delete lines
            'L' => self.push_action(TerminalAction::InsertLines(arg)),
            'M' => self.push_action(TerminalAction::DeleteLines(arg)),

            // Insert/delete characters
            '@' => self.push_action(TerminalAction::InsertLines(arg)),
            'P' => self.push_action(TerminalAction::DeleteChars(arg)),
            'X' => self.push_action(TerminalAction::EraseChars(arg)),

            // Scroll up/down
            'S' => self.push_action(TerminalAction::ScrollUp(arg)),
            'T' => self.push_action(TerminalAction::ScrollDown(arg)),

            // SGR - Select Graphic Rendition
            'm' => self.handle_sgr(params),

            // Device status report and other sequences we acknowledge but don't handle
            'n' | 'c' | 'q' => {}

            _ => {
                // Unknown CSI sequence - log for debugging if needed
            }
        }
    }

    /// Handle private mode sequences (CSI ? ... h/l)
    fn handle_private_mode(&mut self, params: &Params, action: char) {
        let set = action == 'h';

        for param in params.iter() {
            if let Some(&code) = param.first() {
                let mode = match code {
                    1 => Some(Mode::AppCursor),
                    3 => continue, // 80/132 column mode - ignore
                    6 => Some(Mode::Origin),
                    7 => Some(Mode::LineWrap),
                    12 => continue, // Cursor blink - handled elsewhere
                    25 => Some(Mode::ShowCursor),
                    1000 => Some(Mode::MouseX10),
                    1002 => Some(Mode::MouseButtonEvent),
                    1003 => Some(Mode::MouseAnyEvent),
                    1004 => Some(Mode::MouseFocus),
                    1005 => Some(Mode::MouseUtf8),
                    1006 => Some(Mode::MouseSgr),
                    1015 => Some(Mode::MouseUrxvt),
                    1049 => Some(Mode::AltScreen),
                    2004 => Some(Mode::BracketedPaste),
                    _ => None,
                };

                if let Some(mode) = mode {
                    if set {
                        self.push_action(TerminalAction::SetMode(mode));
                    } else {
                        self.push_action(TerminalAction::UnsetMode(mode));
                    }
                }
            }
        }
    }

    /// Handle OSC (Operating System Command) sequences
    fn handle_osc(&mut self, params: &[&[u8]]) {
        if params.is_empty() {
            return;
        }

        // Parse the command number
        let command = match std::str::from_utf8(params[0]) {
            Ok(s) => s.parse::<u16>().ok(),
            Err(_) => None,
        };

        match command {
            // Set window title (OSC 0, 1, 2)
            Some(0) | Some(1) | Some(2) => {
                if params.len() > 1 {
                    if let Ok(title) = std::str::from_utf8(params[1]) {
                        self.push_action(TerminalAction::SetTitle(title.to_string()));
                    }
                }
            }

            // Hyperlink (OSC 8)
            Some(8) => {
                if params.len() >= 2 {
                    let id = if params.len() > 1 && !params[1].is_empty() {
                        std::str::from_utf8(params[1]).ok().map(|s| s.to_string())
                    } else {
                        None
                    };

                    let url = if params.len() > 2 && !params[2].is_empty() {
                        std::str::from_utf8(params[2]).ok().map(|s| s.to_string())
                    } else {
                        None
                    };

                    self.push_action(TerminalAction::SetHyperlink { url, id });
                }
            }

            // Color palette manipulation (OSC 4, 10, 11, etc.)
            // These are acknowledged but not implemented yet
            Some(4) | Some(10) | Some(11) | Some(12) => {}

            // Unknown OSC sequence
            _ => {}
        }
    }
}

impl Perform for AnsiPerformer {
    fn print(&mut self, c: char) {
        self.push_action(TerminalAction::Print(c));
    }

    fn execute(&mut self, byte: u8) {
        match byte {
            // Null
            0x00 => {}
            // Bell
            0x07 => self.push_action(TerminalAction::Bell),
            // Backspace
            0x08 => self.push_action(TerminalAction::Backspace),
            // Tab
            0x09 => self.push_action(TerminalAction::Tab),
            // Line feed
            0x0a => self.push_action(TerminalAction::LineFeed),
            // Vertical tab (treat as line feed)
            0x0b => self.push_action(TerminalAction::LineFeed),
            // Form feed (treat as line feed)
            0x0c => self.push_action(TerminalAction::LineFeed),
            // Carriage return
            0x0d => self.push_action(TerminalAction::CarriageReturn),
            // Shift out/in (character set selection - ignored)
            0x0e | 0x0f => {}
            // XON/XOFF flow control (ignored)
            0x11 | 0x13 => {}
            // Cancel/substitute (interrupt escape sequence)
            0x18 | 0x1a => {}
            // Escape (handled by vte)
            0x1b => {}
            _ => {
                // Other control characters
                self.push_action(TerminalAction::Execute(byte));
            }
        }
    }

    fn hook(&mut self, params: &Params, intermediates: &[u8], ignore: bool, action: char) {
        // DCS (Device Control String) start
        // We acknowledge this but don't implement complex DCS sequences yet
        self.dcs_buffer.clear();
    }

    fn put(&mut self, byte: u8) {
        // DCS data
        self.dcs_buffer.push(byte);
    }

    fn unhook(&mut self) {
        // DCS end
        self.dcs_buffer.clear();
    }

    fn osc_dispatch(&mut self, params: &[&[u8]], _bell_terminated: bool) {
        self.handle_osc(params);
    }

    fn csi_dispatch(
        &mut self,
        params: &Params,
        intermediates: &[u8],
        ignore: bool,
        action: char,
    ) {
        self.handle_csi(params, intermediates, ignore, action);
    }

    fn esc_dispatch(&mut self, intermediates: &[u8], ignore: bool, byte: u8) {
        if ignore {
            return;
        }

        match (intermediates, byte) {
            // Reset
            ([b'c'], _) | ([], b'c') => self.push_action(TerminalAction::Reset),

            // Reverse index (move up and scroll if needed)
            ([], b'M') => self.push_action(TerminalAction::ReverseIndex),

            // Save cursor
            ([b'7'], _) | ([], b'7') => self.push_action(TerminalAction::CursorSave),

            // Restore cursor
            ([b'8'], _) | ([], b'8') => self.push_action(TerminalAction::CursorRestore),

            // Character set selection (ignored for now)
            ([b'('], _) | ([b')'], _) | ([b'*'], _) | ([b'+'], _) => {}

            // Keypad modes
            ([], b'=') => self.push_action(TerminalAction::SetMode(Mode::AppKeypad)),
            ([], b'>') => self.push_action(TerminalAction::UnsetMode(Mode::AppKeypad)),

            _ => {
                // Unknown escape sequence
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_print() {
        let mut performer = AnsiPerformer::new();
        performer.print('A');
        let actions = performer.take_actions();
        assert_eq!(actions.len(), 1);
        assert!(matches!(actions[0], TerminalAction::Print('A')));
    }

    #[test]
    fn test_execute_control_chars() {
        let mut performer = AnsiPerformer::new();
        performer.execute(0x07); // Bell
        performer.execute(0x08); // Backspace
        performer.execute(0x09); // Tab
        performer.execute(0x0a); // Line feed
        performer.execute(0x0d); // Carriage return

        let actions = performer.take_actions();
        assert_eq!(actions.len(), 5);
        assert!(matches!(actions[0], TerminalAction::Bell));
        assert!(matches!(actions[1], TerminalAction::Backspace));
        assert!(matches!(actions[2], TerminalAction::Tab));
        assert!(matches!(actions[3], TerminalAction::LineFeed));
        assert!(matches!(actions[4], TerminalAction::CarriageReturn));
    }

    #[test]
    fn test_sgr_reset() {
        let mut performer = AnsiPerformer::new();
        let params = Params::from_iter([[0]]);
        performer.handle_sgr(&params);

        let actions = performer.take_actions();
        assert_eq!(actions.len(), 1);
        assert!(matches!(actions[0], TerminalAction::ResetAttributes));
    }

    #[test]
    fn test_sgr_attributes() {
        let mut performer = AnsiPerformer::new();
        let params = Params::from_iter([[1], [3], [4]]);
        performer.handle_sgr(&params);

        let actions = performer.take_actions();
        assert_eq!(actions.len(), 3);
        assert!(matches!(
            actions[0],
            TerminalAction::SetAttribute(AttributeChange::Bold)
        ));
        assert!(matches!(
            actions[1],
            TerminalAction::SetAttribute(AttributeChange::Italic)
        ));
    }

    #[test]
    fn test_color_parsing() {
        let mut performer = AnsiPerformer::new();

        // Named color
        let params = Params::from_iter([[31]]);
        performer.handle_sgr(&params);

        let actions = performer.take_actions();
        assert!(matches!(
            actions[0],
            TerminalAction::SetForeground(Color::Named(NamedColor::Red))
        ));

        // 256 color
        let params = Params::from_iter([[38], [5], [196]]);
        performer.handle_sgr(&params);

        let actions = performer.take_actions();
        assert!(matches!(
            actions[0],
            TerminalAction::SetForeground(Color::Indexed(196))
        ));

        // RGB color
        let params = Params::from_iter([[38], [2], [255], [128], [64]]);
        performer.handle_sgr(&params);

        let actions = performer.take_actions();
        if let TerminalAction::SetForeground(Color::Rgb(rgb)) = &actions[0] {
            assert_eq!(rgb.r, 255);
            assert_eq!(rgb.g, 128);
            assert_eq!(rgb.b, 64);
        } else {
            panic!("Expected RGB color");
        }
    }
}
