//! Event Handling System
//!
//! This module defines the event system for the editor, including:
//! - Event types (keyboard, mouse, window, file system)
//! - Event dispatcher
//! - Event handler traits
//! - Event routing and propagation
//!
//! # Architecture
//!
//! The event system uses a centralized dispatcher that routes events to
//! the appropriate handlers. Events can be:
//! - Keyboard events (key press, key release, text input)
//! - Mouse events (click, drag, scroll)
//! - Window events (resize, focus, close)
//! - File system events (file changed, deleted, created)
//! - Command events (direct command execution)
//!
//! # Example
//!
//! ```
//! use events::{EventDispatcher, EditorEvent, KeyEvent};
//!
//! let mut dispatcher = EventDispatcher::new();
//! let event = EditorEvent::KeyPress(KeyEvent::new(...));
//! dispatcher.dispatch(event);
//! ```

pub mod keyboard;

use crate::commands::{Command, Key, KeyMap, Modifiers};
use std::path::PathBuf;
use std::sync::mpsc::{channel, Receiver, Sender};

/// Events that can occur in the editor
#[derive(Debug, Clone)]
pub enum EditorEvent {
    /// Keyboard key press
    KeyPress(KeyEvent),

    /// Keyboard key release
    KeyRelease(KeyEvent),

    /// Text input (after IME composition)
    TextInput(String),

    /// Mouse event
    Mouse(MouseEvent),

    /// Window event
    Window(WindowEvent),

    /// File system event
    FileSystem(FileSystemEvent),

    /// Command execution request
    Command(Command),

    /// Timer event
    Timer(TimerId),

    /// Custom event (for plugins/extensions)
    Custom {
        name: String,
        data: String,
    },
}

/// Keyboard event with key and modifiers
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct KeyEvent {
    /// The key that was pressed
    pub key: Key,

    /// Modifier keys held during the event
    pub modifiers: Modifiers,

    /// Text generated by this key event (if any)
    pub text: Option<String>,

    /// Whether this is a repeat event (key held down)
    pub repeat: bool,
}

impl KeyEvent {
    /// Create a new key event
    pub fn new(key: Key, modifiers: Modifiers) -> Self {
        Self {
            key,
            modifiers,
            text: None,
            repeat: false,
        }
    }

    /// Create a key event with text
    pub fn with_text(key: Key, modifiers: Modifiers, text: String) -> Self {
        Self {
            key,
            modifiers,
            text: Some(text),
            repeat: false,
        }
    }

    /// Set whether this is a repeat event
    pub fn with_repeat(mut self, repeat: bool) -> Self {
        self.repeat = repeat;
        self
    }

    /// Check if this event represents a printable character
    pub fn is_printable(&self) -> bool {
        matches!(self.key, Key::Char(_)) && !self.modifiers.ctrl && !self.modifiers.alt
    }

    /// Get the text that should be inserted for this key event
    pub fn text_to_insert(&self) -> Option<&str> {
        if self.is_printable() {
            if let Some(text) = &self.text {
                return Some(text);
            }
            // Note: In practice, text should always be provided by the UI layer
            // We cannot return a reference to a temporary char-to-string conversion
        }
        None
    }
}

/// Mouse event types
#[derive(Debug, Clone)]
pub enum MouseEvent {
    /// Mouse button pressed
    ButtonPress {
        position: ScreenPosition,
        button: MouseButton,
        modifiers: Modifiers,
    },

    /// Mouse button released
    ButtonRelease {
        position: ScreenPosition,
        button: MouseButton,
        modifiers: Modifiers,
    },

    /// Mouse moved
    Move {
        position: ScreenPosition,
        modifiers: Modifiers,
    },

    /// Mouse dragged (moved while button pressed)
    Drag {
        start: ScreenPosition,
        current: ScreenPosition,
        button: MouseButton,
        modifiers: Modifiers,
    },

    /// Mouse wheel scrolled
    Scroll {
        delta: ScrollDelta,
        position: ScreenPosition,
        modifiers: Modifiers,
    },

    /// Mouse entered editor area
    Enter {
        position: ScreenPosition,
    },

    /// Mouse left editor area
    Leave {
        position: ScreenPosition,
    },
}

/// Screen position (pixel coordinates)
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct ScreenPosition {
    pub x: f32,
    pub y: f32,
}

impl ScreenPosition {
    pub fn new(x: f32, y: f32) -> Self {
        Self { x, y }
    }
}

/// Mouse button types
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum MouseButton {
    /// Left mouse button
    Left,

    /// Right mouse button
    Right,

    /// Middle mouse button
    Middle,

    /// Additional button (back)
    Back,

    /// Additional button (forward)
    Forward,
}

/// Scroll delta
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct ScrollDelta {
    /// Horizontal scroll amount
    pub x: f32,

    /// Vertical scroll amount
    pub y: f32,
}

impl ScrollDelta {
    pub fn new(x: f32, y: f32) -> Self {
        Self { x, y }
    }
}

/// Window events
#[derive(Debug, Clone)]
pub enum WindowEvent {
    /// Window resized
    Resize {
        width: u32,
        height: u32,
    },

    /// Window gained focus
    Focus,

    /// Window lost focus
    Blur,

    /// Window close requested
    CloseRequested,

    /// Window moved
    Moved {
        x: i32,
        y: i32,
    },

    /// Window minimized/iconified
    Minimized,

    /// Window maximized
    Maximized,

    /// Window restored from minimized/maximized
    Restored,

    /// DPI scale factor changed
    ScaleFactorChanged {
        scale_factor: f64,
    },
}

/// File system events
#[derive(Debug, Clone)]
pub enum FileSystemEvent {
    /// File was modified
    FileChanged {
        path: PathBuf,
    },

    /// File was deleted
    FileDeleted {
        path: PathBuf,
    },

    /// File was created
    FileCreated {
        path: PathBuf,
    },

    /// File was renamed
    FileRenamed {
        from: PathBuf,
        to: PathBuf,
    },

    /// Directory was modified
    DirectoryChanged {
        path: PathBuf,
    },
}

/// Timer identifier
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct TimerId(pub u64);

/// Event handler trait
///
/// Implement this trait to handle events. The handler can return
/// whether the event was handled (true) or should continue propagating (false).
pub trait EventHandler {
    /// Handle an event
    ///
    /// Returns true if the event was handled and should not propagate further.
    fn handle_event(&mut self, event: &EditorEvent) -> bool;
}

/// Event dispatcher
///
/// Routes events to handlers and manages the event queue.
pub struct EventDispatcher {
    /// Event queue
    event_tx: Sender<EditorEvent>,
    event_rx: Receiver<EditorEvent>,

    /// Keymap for translating key events to commands
    keymap: KeyMap,

    /// Registered event handlers
    handlers: Vec<Box<dyn EventHandler>>,

    /// Whether to consume events after handling
    consume_handled_events: bool,
}

impl EventDispatcher {
    /// Create a new event dispatcher
    pub fn new() -> Self {
        let (tx, rx) = channel();
        Self {
            event_tx: tx,
            event_rx: rx,
            keymap: KeyMap::default(),
            handlers: Vec::new(),
            consume_handled_events: true,
        }
    }

    /// Create a new event dispatcher with a custom keymap
    pub fn with_keymap(keymap: KeyMap) -> Self {
        let (tx, rx) = channel();
        Self {
            event_tx: tx,
            event_rx: rx,
            keymap,
            handlers: Vec::new(),
            consume_handled_events: true,
        }
    }

    /// Get a sender for posting events to the queue
    pub fn sender(&self) -> Sender<EditorEvent> {
        self.event_tx.clone()
    }

    /// Post an event to the queue
    pub fn post(&self, event: EditorEvent) {
        let _ = self.event_tx.send(event);
    }

    /// Register an event handler
    pub fn add_handler(&mut self, handler: Box<dyn EventHandler>) {
        self.handlers.push(handler);
    }

    /// Get a reference to the keymap
    pub fn keymap(&self) -> &KeyMap {
        &self.keymap
    }

    /// Get a mutable reference to the keymap
    pub fn keymap_mut(&mut self) -> &mut KeyMap {
        &mut self.keymap
    }

    /// Process the next event in the queue
    ///
    /// Returns Some(event) if an event was processed, None if the queue is empty.
    pub fn process_next(&mut self) -> Option<EditorEvent> {
        if let Ok(event) = self.event_rx.try_recv() {
            self.dispatch(event.clone());
            Some(event)
        } else {
            None
        }
    }

    /// Process all pending events
    ///
    /// Returns the number of events processed.
    pub fn process_all(&mut self) -> usize {
        let mut count = 0;
        while self.process_next().is_some() {
            count += 1;
        }
        count
    }

    /// Dispatch an event to handlers
    ///
    /// Translates keyboard events to commands via the keymap,
    /// then passes to registered handlers.
    fn dispatch(&mut self, event: EditorEvent) {
        // Translate key events to commands
        let event = if let EditorEvent::KeyPress(ref key_event) = event {
            if let Some(command) = self.keymap.lookup(key_event.key, key_event.modifiers) {
                EditorEvent::Command(command.clone())
            } else {
                event
            }
        } else {
            event
        };

        // Pass to handlers
        for handler in &mut self.handlers {
            if handler.handle_event(&event) && self.consume_handled_events {
                // Event was handled, stop propagation
                break;
            }
        }
    }

    /// Wait for and process the next event (blocking)
    ///
    /// This will block until an event is available.
    pub fn wait_for_event(&mut self) -> EditorEvent {
        let event = self.event_rx.recv().expect("Event channel closed");
        self.dispatch(event.clone());
        event
    }
}

impl Default for EventDispatcher {
    fn default() -> Self {
        Self::new()
    }
}

/// Event filter trait
///
/// Allows filtering/transforming events before they reach handlers.
pub trait EventFilter {
    /// Filter an event
    ///
    /// Returns Some(event) to continue processing (possibly transformed),
    /// or None to drop the event.
    fn filter(&mut self, event: EditorEvent) -> Option<EditorEvent>;
}

/// Click type detection for mouse events
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ClickType {
    /// Single click
    Single,

    /// Double click
    Double,

    /// Triple click
    Triple,
}

/// Click detector for detecting double/triple clicks
pub struct ClickDetector {
    last_click_time: Option<std::time::Instant>,
    last_click_position: Option<ScreenPosition>,
    click_count: u8,
    double_click_time_ms: u64,
    double_click_distance: f32,
}

impl ClickDetector {
    /// Create a new click detector
    pub fn new() -> Self {
        Self {
            last_click_time: None,
            last_click_position: None,
            click_count: 0,
            double_click_time_ms: 500,
            double_click_distance: 5.0,
        }
    }

    /// Register a click and detect the click type
    pub fn register_click(&mut self, position: ScreenPosition) -> ClickType {
        let now = std::time::Instant::now();

        let is_multi_click = if let Some(last_time) = self.last_click_time {
            let elapsed = now.duration_since(last_time).as_millis() as u64;
            let distance = if let Some(last_pos) = self.last_click_position {
                ((position.x - last_pos.x).powi(2) + (position.y - last_pos.y).powi(2)).sqrt()
            } else {
                f32::MAX
            };

            elapsed < self.double_click_time_ms && distance < self.double_click_distance
        } else {
            false
        };

        if is_multi_click {
            self.click_count = (self.click_count + 1).min(3);
        } else {
            self.click_count = 1;
        }

        self.last_click_time = Some(now);
        self.last_click_position = Some(position);

        match self.click_count {
            1 => ClickType::Single,
            2 => ClickType::Double,
            _ => ClickType::Triple,
        }
    }

    /// Reset the click detector
    pub fn reset(&mut self) {
        self.click_count = 0;
        self.last_click_time = None;
        self.last_click_position = None;
    }
}

impl Default for ClickDetector {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    struct TestHandler {
        events_received: Vec<String>,
    }

    impl TestHandler {
        fn new() -> Self {
            Self {
                events_received: Vec::new(),
            }
        }
    }

    impl EventHandler for TestHandler {
        fn handle_event(&mut self, event: &EditorEvent) -> bool {
            self.events_received.push(format!("{:?}", event));
            false // Don't consume events
        }
    }

    #[test]
    fn test_event_dispatcher_post_and_process() {
        let mut dispatcher = EventDispatcher::new();
        let handler = TestHandler::new();
        dispatcher.add_handler(Box::new(handler));

        let event = EditorEvent::Command(Command::Save);
        dispatcher.post(event);

        assert_eq!(dispatcher.process_all(), 1);
    }

    #[test]
    fn test_key_event_printable() {
        let event = KeyEvent::new(Key::Char('a'), Modifiers::none());
        assert!(event.is_printable());

        let event = KeyEvent::new(Key::Char('a'), Modifiers::ctrl());
        assert!(!event.is_printable());
    }

    #[test]
    fn test_click_detector_single() {
        let mut detector = ClickDetector::new();
        let pos = ScreenPosition::new(10.0, 20.0);

        let click_type = detector.register_click(pos);
        assert_eq!(click_type, ClickType::Single);
    }

    #[test]
    fn test_click_detector_double() {
        let mut detector = ClickDetector::new();
        let pos = ScreenPosition::new(10.0, 20.0);

        detector.register_click(pos);
        let click_type = detector.register_click(pos);
        assert_eq!(click_type, ClickType::Double);
    }

    #[test]
    fn test_screen_position() {
        let pos = ScreenPosition::new(10.0, 20.0);
        assert_eq!(pos.x, 10.0);
        assert_eq!(pos.y, 20.0);
    }
}
